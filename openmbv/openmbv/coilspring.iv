#Inventor V2.1 ascii

Separator {
  # global coordinates and normals
  DEF openmbv_coilspring_coords Coordinate3 {
    point [ # Dummy normals are needed here -> will be overwritten in the vertex shader
            # If you set coordindates here, these will be used for coin bbox calculation and picking, ... (but will be wrong)
      @vertexDummyStr@
    ]
  }
  Normal {
    vector [ # Dummy normals are needed here -> will be overwritten in the vertex shader
            # If you set coordindates here, these will be used for coin bbox calculation and picking, ... (but will be wrong)
      @normalDummyStr@
    ]
  }
  ShapeHints {
    vertexOrdering COUNTERCLOCKWISE
    shapeType SOLID
  }
  DEF openmbv_coilspring_sepnopicknobbox SepNoPickNoBBox { # Coin just knows the dummy vertex pos -> we need to disable pick and bbox calculation for this node
    skipBBox FALSE
    ShaderProgram {
      shaderObject [
        VertexShader {
          sourceType GLSL_PROGRAM
          sourceProgram "
            #version 130

            #define M_PI 3.14159265358979

            out vec3 worldNormal;
            attribute float vertexID_float;
            uniform float length;

            mat3 cardan2Rotation(vec3 angle) {
              float sina = sin(angle.x);
              float cosa = cos(angle.x);
              float sinb = sin(angle.y);
              float cosb = cos(angle.y);
              float sing = sin(angle.z);
              float cosg = cos(angle.z);
              mat3 T;
              T[0][0] = cosb*cosg;
              T[1][0] = -cosb*sing;
              T[2][0] = sinb;
              T[0][1] = cosa*sing+sina*sinb*cosg;
              T[1][1] = cosa*cosg-sina*sinb*sing;
              T[2][1] = -sina*cosb;
              T[0][2] = sina*sing-cosa*sinb*cosg;
              T[1][2] = cosa*sinb*sing+sina*cosg;
              T[2][2] = cosa*cosb;
              return T;
            }

            vec3 calcr(int spIdx) {
              float alpha = spIdx*2.*M_PI/@numberOfSpinePointsPerCoil@;
              vec3 r = vec3(
                @R@*cos(alpha),
                @R@*sin(alpha),
                spIdx*length/@numberOfSpinePointsPerCoil@/@N@
              );
              return r;
            }

            float atan2(float y, float x) {
              if(x> 0        ) return atan(y/x);
              if(x< 0 && y>=0) return atan(y/x)+M_PI;
              if(x< 0 && y< 0) return atan(y/x)-M_PI;
              if(x==0 && y> 0) return +M_PI/2;
              if(x==0 && y< 0) return -M_PI/2;
              return 0.0;
            }

            vec3 calcAngle(int spIdx) {
              float alpha = spIdx*2.*M_PI/@numberOfSpinePointsPerCoil@;
              float n = atan( length / ( @N@*2.*M_PI*@R@ ) );
              // angle = rotation2Cardan(cardan2Rotation(0,0,alpha)*cardan2Rotation(n,0,0));
              float sinn = sin(n);
              float cosn = cos(n);
              float sinalpha = sin(alpha);
              float cosalpha = cos(alpha);
              vec3 angle = vec3(
                atan2(sinn*cosalpha, cosn),
                asin(sinalpha*sinn),
                atan2(sinalpha*cosn, cosalpha)
              );
              return angle;
            }

            vec3 calcPoint(int vertexID, vec3 angle) {
              int csIdx = int(vertexID % @Ncs@);
              int spIdx = int(vertexID / @Ncs@);
              float arg = csIdx*2.*M_PI/@Ncs@;
              vec3 nsp = vec3(@r@*cos(arg), 0, -@r@*sin(arg));
              vec3 r = calcr(spIdx);
              mat3 T = cardan2Rotation(angle);
              vec3 T_nsp = T * nsp;
              return r + T_nsp;
            }

            vec3 calcNormal(int vertexID, vec3 angle) {
              int csIdx = int(vertexID % @Ncs@);
              float arg = csIdx*2.*M_PI/@Ncs@;
              vec3 normal = vec3(cos(arg), 0, -sin(arg));
              mat3 T = cardan2Rotation(angle);
              vec3 n = T * normal;
              return n;
            }
             
            void main(void)
            {
              int vertexID = int(vertexID_float+0.5);

              int spIdx = int(vertexID / @Ncs@);
              vec3 angle = calcAngle(spIdx);
              vec3 c = calcPoint(vertexID, angle);
              vec3 n = calcNormal(vertexID, angle);

              worldNormal = normalize(gl_NormalMatrix * n);
              gl_Position = gl_ModelViewProjectionMatrix * vec4(c, gl_Vertex.w);
              gl_FrontColor = gl_Color;
            }
          "
          parameter [
            ShaderParameter1f {
              name "length"
              value = USE openmbv_coilspring_length.value
            }
          ]
        }
        FragmentShader {
          sourceType GLSL_PROGRAM
          sourceProgram "
            #version 130

            in vec3 worldNormal;
             
            void directionalLight(in int i,
                                  in vec3 worldNormal,
                                  inout vec4 ambient,
                                  inout vec4 diffuse,
                                  inout vec4 specular)
            {
              float nDotVP; // normal . light direction
              float nDotHV; // normal . light half vector
              float pf;     // power factor
             
              nDotVP = max(0.0, dot(worldNormal, normalize(vec3(gl_LightSource[i].position))));
             
              if (nDotVP == 0.0)
                pf = 0.0;
              else {
                nDotHV = max(0.0, dot(worldNormal, vec3(gl_LightSource[i].halfVector)));
                pf = pow(nDotHV, gl_FrontMaterial.shininess);
              }
             
              ambient += gl_LightSource[i].ambient;
              diffuse += gl_LightSource[i].diffuse * nDotVP;
              specular += gl_LightSource[i].specular * pf;
            }
             
            void main(void)
            {
              vec4 ambient = vec4(0.0);
              vec4 diffuse = vec4(0.0);
              vec4 specular = vec4(0.0);
              vec3 color;
             
              directionalLight(0, normalize(worldNormal), ambient, diffuse, specular);//mfmf use more lights and also spot-lights,...
             
              color =
                gl_FrontLightModelProduct.sceneColor.rgb +
                ambient.rgb * gl_FrontMaterial.ambient.rgb +
                diffuse.rgb * gl_Color.rgb +
                specular.rgb * gl_FrontMaterial.specular.rgb;
             
              gl_FragColor = vec4(color, gl_Color.a);
            }
          "
        }
      ]
    }
    VertexAttribute {
      typeName "SoMFFloat" # Coin only supports short as int type, which is too small.
                           # Coin will convert a int type to float since glVertexAttribPointerARB not glVertexAttriblPointerARB is used
                           # -> use a (none negative) float as ID and convert it to in in the vertex shader
      name "vertexID_float"
      values [ @vertexAttributeStr@ ]
    }
    # tube
    IndexedFaceSet { # Coin does not pass VertexAttribut's to IndexedTriangleStripSet -> use IndexedFaceSet
      coordIndex [
        @meshCoordIndexStr@
      ]
      # we cannot use normalIndex/... since the vertex shader calculates exactly one normal per vertex (per Coordinate3)
    }
  }
  # end-cap
  NormalBinding {
    value OVERALL
  }
  DEF endCapCoords Coordinate3 {
    point [
      @nspStr2@
    ]
  }
  Separator {
    Normal {
      vector 0 -1 0
    }
    ShapeHints {
      vertexOrdering CLOCKWISE
      shapeType SOLID
    }
    DEF endCap1Trans Transform {
    }
    DEF endCapIndexedTesselationFace IndexedTesselationFace {
      windingRule ODD
      coordinate = USE endCapCoords.point
      coordIndex [
        @NcsStr@
      ]
    }
    # outline
    DEF outLineStyle Material {
      diffuseColor 0 0 0
    }
    DEF endCapOutLine IndexedLineSet {
      coordIndex [
        @NcsStr@
      ]
    }
  }
  Separator {
    Normal {
      vector 0 +1 0
    }
    ShapeHints {
      vertexOrdering COUNTERCLOCKWISE
      shapeType SOLID
    }
    DEF endCap2Trans Transform {
    }
    USE endCapIndexedTesselationFace
    # outline
    USE outLineStyle
    USE endCapOutLine
  }
}
