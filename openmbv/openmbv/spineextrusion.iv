#Inventor V2.1 ascii

Separator {
  # global coordinates and normals
  DEF openmbv_spineextrusion_coords Coordinate3 {
    point [ # Dummy normals are needed here -> will be overwritten in the vertex shader
            # If you set coordindates here, these will be used for coin bbox calculation and picking, ... (but will be wrong)
      @vertexDummyStr@
    ]
  }
  Normal {
    vector [ # Dummy normals are needed here -> will be overwritten in the vertex shader
            # If you set coordindates here, these will be used for coin bbox calculation and picking, ... (but will be wrong)
      @normalDummyStr@
    ]
  }
  ShapeHints {
    vertexOrdering @tubeCCW@
    shapeType SOLID
  }
  SepNoPickNoBBox { # Coin just knows the dummy vertex pos -> we need to disable pick and bbox calculation for this node
    ShaderProgram {
      shaderObject [
        VertexShader {
          sourceType GLSL_PROGRAM
          sourceProgram "
            #version 130

            out vec3 worldNormal;
            attribute float vertexID_float;
            uniform float data[6*@Nsp@+1];

            mat3 cardan2Rotation(vec3 angle) {
              float sina = sin(angle.x);
              float cosa = cos(angle.x);
              float sinb = sin(angle.y);
              float cosb = cos(angle.y);
              float sing = sin(angle.z);
              float cosg = cos(angle.z);
              mat3 T;
              T[0][0] = cosb*cosg;
              T[1][0] = -cosb*sing;
              T[2][0] = sinb;
              T[0][1] = cosa*sing+sina*sinb*cosg;
              T[1][1] = cosa*cosg-sina*sinb*sing;
              T[2][1] = -sina*cosb;
              T[0][2] = sina*sing-cosa*sinb*cosg;
              T[1][2] = cosa*sinb*sing+sina*cosg;
              T[2][2] = cosa*cosb;
              return T;
            }

            vec3 calcPoint(int vertexID) {
              const vec3 nsp[@Ncs@] = vec3[](
@nspStr@
              );

              int csIdx = int(vertexID/2 % @Ncs@);
              int spIdx = int(vertexID/2 / @Ncs@);
              vec3 r = vec3(data[spIdx*6+1],data[spIdx*6+2],data[spIdx*6+3]);
              vec3 angle = vec3(data[spIdx*6+4],data[spIdx*6+5],data[spIdx*6+6]);
              mat3 T = cardan2Rotation(angle);
              vec3 T_nsp = T * nsp[csIdx];
              return r + T_nsp;
            }

            vec3 calcNormal(int vertexID) {
              const vec3 normal[2*@Ncs@] = vec3[](
@normalStr@
              );
              const int border[@Ncs@] = int[](
@borderStr@
              );

              int nIdx = int(vertexID % (2*@Ncs@));
              int spIdx = int(vertexID/2 / @Ncs@);
              vec3 angle = vec3(data[spIdx*6+4],data[spIdx*6+5],data[spIdx*6+6]);
              mat3 T = cardan2Rotation(angle);
              vec3 n = T * normal[nIdx];
              // normals x b
              int spIdxA = spIdx==0 ? 0 : (spIdx-1)*6;
              int spIdxB = spIdx==@Nsp@-1 ? spIdx*6 : (spIdx+1)*6;
              vec3 spA = vec3(data[spIdxA+1],data[spIdxA+2],data[spIdxA+3]);
              vec3 spB = vec3(data[spIdxB+1],data[spIdxB+2],data[spIdxB+3]);
              vec3 b = spB - spA;
              vec3 x = dot(n,b)/dot(b,b)*b;
              n = normalize(n-x);
              return n;
            }
             
            void main(void)
            {
              int vertexID = int(vertexID_float+0.5);

              vec3 c = calcPoint(vertexID);
              vec3 n = calcNormal(vertexID);

              worldNormal = normalize(gl_NormalMatrix * n);
              gl_Position = gl_ModelViewProjectionMatrix * vec4(c, gl_Vertex.w);
              gl_FrontColor = gl_Color;
            }
          "
          parameter [
            ShaderParameterArray1f {
              name "data"
              value = USE openmbv_spineextrusion_data.value
            }
          ]
        }
        FragmentShader {
          sourceType GLSL_PROGRAM
          sourceProgram "
            #version 130

            in vec3 worldNormal;
             
            void directionalLight(in int i,
                                  in vec3 worldNormal,
                                  inout vec4 ambient,
                                  inout vec4 diffuse,
                                  inout vec4 specular)
            {
              float nDotVP; // normal . light direction
              float nDotHV; // normal . light half vector
              float pf;     // power factor
             
              nDotVP = max(0.0, dot(worldNormal, normalize(vec3(gl_LightSource[i].position))));
             
              if (nDotVP == 0.0)
                pf = 0.0;
              else {
                nDotHV = max(0.0, dot(worldNormal, vec3(gl_LightSource[i].halfVector)));
                pf = pow(nDotHV, gl_FrontMaterial.shininess);
              }
             
              ambient += gl_LightSource[i].ambient;
              diffuse += gl_LightSource[i].diffuse * nDotVP;
              specular += gl_LightSource[i].specular * pf;
            }
             
            void main(void)
            {
              vec4 ambient = vec4(0.0);
              vec4 diffuse = vec4(0.0);
              vec4 specular = vec4(0.0);
              vec3 color;
             
              directionalLight(0, normalize(worldNormal), ambient, diffuse, specular);//mfmf use more lights and also spot-lights,...
             
              color =
                gl_FrontLightModelProduct.sceneColor.rgb +
                ambient.rgb * gl_FrontMaterial.ambient.rgb +
                diffuse.rgb * gl_Color.rgb +
                specular.rgb * gl_FrontMaterial.specular.rgb;
             
              gl_FragColor = vec4(color, gl_Color.a);
            }
          "
        }
      ]
    }
    VertexAttribute {
      typeName "SoMFFloat" # Coin only supports short as int type, which is too small.
                           # Coin will convert a int type to float since glVertexAttribPointerARB not glVertexAttriblPointerARB is used
                           # -> use a (none negative) float as ID and convert it to in in the vertex shader
      name "vertexID_float"
      values [ @vertexAttributeStr@ ]
    }
    # tube
    IndexedFaceSet { # Coin does not pass VertexAttribut's to IndexedTriangleStripSet -> use IndexedFaceSet
      coordIndex [
        @meshCoordIndexStr@
      ]
      # we cannot use normalIndex/... since the vertex shader calculates exactly one normal per vertex (per Coordinate3)
    }
    # outline
    DEF outLineStyle Material {
      diffuseColor 0 0 0
    }
    IndexedLineSet {
      coordIndex [
        @tubeCoordIndexStr@
      ]
    }
  }
  # end-cap
  NormalBinding {
    value OVERALL
  }
  DEF endCapCoords Coordinate3 {
    point [
      @nspStr2@
    ]
  }
  Separator {
    Normal {
      vector @endCap1Normal@
    }
    ShapeHints {
      vertexOrdering @endCap1CCW@
      shapeType SOLID
    }
    Transform {
      translation = DecomposeArray1fToVec3fEngine {
        startIndex 1
        input = USE openmbv_spineextrusion_data.value
      }.output
      rotation = CardanRotationEngine {
        angle = DecomposeArray1fToVec3fEngine {
          startIndex 4
          input = USE openmbv_spineextrusion_data.value
        }.output
        inverse TRUE
      }.rotation
    }
    DEF endCapIndexedTesselationFace IndexedTesselationFace {
      windingRule ODD
      coordinate = USE endCapCoords.point
      coordIndex [
        @NcsStr@
      ]
    }
    # outline
    USE outLineStyle
    DEF endCapOutLine IndexedLineSet {
      coordIndex [
        @NcsStr@
      ]
    }
  }
  Separator {
    Normal {
      vector @endCap2Normal@
    }
    ShapeHints {
      vertexOrdering @endCap2CCW@
      shapeType SOLID
    }
    Transform {
      translation = DecomposeArray1fToVec3fEngine {
        startIndex @startIndex1@
        input = USE openmbv_spineextrusion_data.value
      }.output
      rotation = CardanRotationEngine {
        angle = DecomposeArray1fToVec3fEngine {
          startIndex @startIndex2@
          input = USE openmbv_spineextrusion_data.value
        }.output
        inverse TRUE
      }.rotation
    }
    USE endCapIndexedTesselationFace
    # outline
    USE outLineStyle
    USE endCapOutLine
  }
}
